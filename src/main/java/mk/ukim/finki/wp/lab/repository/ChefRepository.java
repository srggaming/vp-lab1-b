package mk.ukim.finki.wp.lab.repository; // Го дефинираме пакетот

// Импортираме ги потребните класи
import mk.ukim.finki.wp.lab.model.Chef; // Нашата Chef класа

import java.util.List; // Интерфејс за листа
import java.util.Optional; // Wrapper класа што може да содржи или да не содржи вредност (избегнува null)

/**
 * ChefRepository интерфејс
 * Repository слојот е одговорен за пристап до податоците (Data Access Layer)
 * Овој интерфејс дефинира операции за работа со готвачи
 *
 * Зошто интерфејс?
 * - Дефинира договор (contract) - какви методи мора да постојат
 * - Овозможува лесна замена на имплементацијата (сега користиме in-memory, подоцна може база)
 * - Добра практика во Spring (Dependency Inversion Principle од SOLID)
 */
public interface ChefRepository {

    /**
     * findAll() - Ги враќа сите готвачи
     * Не прима параметри
     * Враќа List<Chef> - листа со сите готвачи во системот
     *
     * @return листа на сите готвачи
     */
    List<Chef> findAll();

    /**
     * findById(Long id) - Го наоѓа готвачот по неговото ID
     * Прима Long id како параметар
     * Враќа Optional<Chef> - може да содржи готвач (ако е пронајден) или да биде празен (ако не е пронајден)
     *
     * Optional е подобро од null бидејќи:
     * - Експлицитно покажува дека резултатот може да не постои
     * - Избегнува NullPointerException
     * - Го прави кодот посигурен и почитлив
     *
     * @param id - идентификатор на готвачот што го бараме
     * @return Optional што може да содржи готвач или да биде празен
     */
    Optional<Chef> findById(Long id);

    /**
     * save(Chef chef) - Го зачувува или ажурира готвачот
     * Ако готвачот со истото ID веќе постои - ќе го ажурира
     * Ако готвачот не постои - ќе го додаде како нов
     * Враќа го зачуваниот/ажурираниот готвач
     *
     * @param chef - готвачот што сакаме да го зачуваме/ажурираме
     * @return зачуваниот готвач
     */
    Chef save(Chef chef);
}
